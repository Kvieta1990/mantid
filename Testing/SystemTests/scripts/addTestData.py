# Mantid Repository : https://github.com/mantidproject/mantid
#
# Copyright &copy; 2020 ISIS Rutherford Appleton Laboratory UKRI,
#   NScD Oak Ridge National Laboratory, European Spallation Source,
#   Institut Laue - Langevin & CSNS, Institute of High Energy Physics, CAS
# SPDX - License - Identifier: GPL - 3.0 +
import argparse
import glob
import hashlib
import itertools
import json
import os
import shutil
from typing import List

FILE_HASH_EXTENSION = '.md5'


def dir_path(path):
    if os.path.isdir(path):
        return path
    else:
        raise NotADirectoryError(path)


class TestDataCreator(object):
    """
    Creates test data according to the specifications outlined in
    https://developer.mantidproject.org/DataFilesForTesting.html
    Each input file is converted to a "Content link" and a "Content" file in three stages:
    (1) The input file is first hashed, to find a unique identifier (hash) for the name
    (2) The input file is then copied and renamed to the hash ("Content file")
    (3) A new file is then generated, which contains the unique identifier of the input file ("Content link file")
    The content link file should be placed in the mantid source directory,
    while the content file is uploaded to the mantid test data server.
    """

    def __init__(self, hasher=hashlib.md5, extension=FILE_HASH_EXTENSION):
        """
        Creates an instance of the TestDataCreator
        The constructor takes two inputs, allowing the hashing algorithm to be specified
        and the extension used to save the content link files (e.g .md5 if we use an md5 hasher (default) ).
        """
        self.input_files = []
        self.content_files = []
        self.content_link_files = []
        self.target_directories = []
        self.hasher = hasher
        self.hash_extension = extension
        self.options = {}

    def process_files(self, file_paths):
        """
        Create a suitable test data file (content and content link file)
        for the input file
        """
        if not isinstance(file_paths, List):
            file_paths = list(file_paths)
        self._process_files_impl(file_paths)

    def _process_files_impl(self, file_paths):
        file_hashes = self.compute_file_hashes(file_paths)
        for file_path, file_hash in file_hashes:
            content_link_file = self.create_content_link_file(file_path, file_hash, self.hash_extension)
            content_file = self.rename_file_to_hash(file_path, file_hash)
            self.input_files.append(file_path)
            self.content_files.append(content_file)
            self.content_link_files.append(content_link_file)

    def process_test_failures(self, test_results, replace=False):
        """
        Process the results from system tests failures
        If the replace argument is supplied, the newly generated
        content link file will be moved to replace the original content link file
        """
        self.create_content_files_from_test_results(test_results)
        if replace:
            self.move_content_link_files(self.target_directories)

    def create_content_files_from_test_results(self, test_results):
        """
        Creates new content files based on the results from system tests.
        This function expects the test entry to be of the form:
            'TestName': Name of the test which failed,
            'MismatchFile': Path to the mismatch file generated by the test,
            'ReferenceFile': Path to reference file,
            'ReferenceContentLinkFiles': Path to the original content link of the reference file
        Each entry needs to be complete in order to be able to generate a new reference file.
        """
        failed_tests = test_results['FailedTests']
        for entry in failed_tests:
            if not self.is_test_entry_complete(entry):
                continue
            for mismatch_file, reference_content_link in zip(entry['MismatchFiles'],
                                                             entry['ReferenceContentLinkFiles']):
                file_hashes = self.compute_file_hashes([mismatch_file])
                hash_value = file_hashes[0][1]
                file_path = mismatch_file.replace("-mismatch", "")
                content_link_file = self.create_content_link_file(file_path, hash_value, self.hash_extension)
                content_file = self.rename_file_to_hash(mismatch_file, hash_value)
                target_directory, _ = os.path.split(reference_content_link)
                self.target_directories.append(target_directory)
                self.content_files.append(content_file)
                self.input_files.append(mismatch_file)
                self.content_link_files.append(content_link_file)

    def compute_file_hashes(self, filenames):
        """Creates a list of hashes for the list of input files"""
        file_hashes = [(filename, self.hash_bytestr_iter(self.file_as_blockiter(filename), self.hasher()))
                       for filename in filenames]
        return file_hashes

    def move_content_link_files(self, target_directories):
        """
        Moves the created content link files to the target directories
        """
        if not self.content_link_files:
            return
        if not isinstance(target_directories, List):
            target_directories = list(target_directories)
        self._move_content_link_files_impl(target_directories)

    def _move_content_link_files_impl(self, target_directories):
        """
        Moves the created content link files to the target directories
        First checks that either a single target directory has been supplied,
        or a directory for each file has been specified for each file
        """
        if len(target_directories) > 1 and len(target_directories) != len(self.content_link_files):
            raise RuntimeError("Must either supply one target directory or a directory for each file")
        if not any(dir_path(directory) for directory in target_directories):
            raise RuntimeError("Must supply a valid target directory to move hash files to")
        for file_path, target_directory in zip(self.content_link_files, itertools.cycle(target_directories)):
            _, filename = os.path.split(file_path)
            shutil.move(filename, os.path.join(target_directory, filename))

    def print_summary(self):
        """
        Prints a summary of the test data created
        """
        if not self.content_link_files or not self.content_files:
            print("Could not create any test data, please check the provided inputs")
            return
        print("## Created test data files for the following input files:")
        for file in self.input_files:
            print(file)
        print("## Please upload the following content files to the remote-store")
        for file in self.content_files:
            print(file)
        print("## Ensure the following content link files are placed in the relevant Mantid test data directory")
        for file in self.content_link_files:
            print(file)

    @staticmethod
    def hash_bytestr_iter(bytesiter, hasher):
        """
        Updates the value of the hash for the file currently being read
        """
        for block in bytesiter:
            hasher.update(block)
        return hasher.hexdigest()

    @staticmethod
    def file_as_blockiter(filename, blocksize=65536):
        """
        Hashes the input file in blocks (so we don't run out of memory)
        """
        try:
            with open(filename, "rb") as afile:
                block = afile.read(blocksize)
                while len(block) > 0:
                    yield block
                    block = afile.read(blocksize)
        except (OSError, IOError):
            pass

    @staticmethod
    def create_content_link_file(original_file, hash_value, hash_extension):
        """
        Creates a content link file with the name filename.extension.self.hash_extension
        The file will contain a single line with the hash value of the content file.
        """
        path, filename = os.path.split(original_file)
        # add the hash extension to the file and save the new file at the same location
        # of the original file
        content_link_filename = filename + hash_extension
        try:
            content_link_file_path = os.path.join(path, content_link_filename)
            with open(content_link_file_path, "w") as outfile:
                outfile.write(hash_value)
            return content_link_file_path
        except (OSError, IOError):
            pass

    @staticmethod
    def rename_file_to_hash(file_path, hash_value):
        """
        Renames the input file to the value contained in the hash
        """
        path, filename = os.path.split(file_path)
        try:
            new_file = os.path.join(path, hash_value)
            shutil.copy(file_path, new_file)
            return new_file
        except (OSError, IOError):
            pass

    @staticmethod
    def is_test_entry_complete(entry):
        """
        Tests whether the FailedTest entry is the test output file is complete.
        """
        return len(entry["MismatchFiles"]) > 0 and len(entry["MismatchFiles"]) == len(entry["ReferenceFiles"]) == \
            len(entry["ReferenceContentLinkFiles"])


def main():
    info = [
        "This program will create a test data (content files and content links) from a set of input files.",
        "It can be used in two ways: (1) Process a json file resulting from failed system test using the"
        " --testresults argument to supply the file, ",
        "or (2) the program can be used to process a list of input files using the --inputfiles and --targetdirectory "
        "arguments. If the content files are generated with the testresults argument, the --replacecontentlinks can be "
        "specified to replace the original content links with the newly generated links."
    ]
    epilog = ["Typical usage on a list of input files: "
              "\"python addTestData.py --inputfiles a.txt b.txt --targetdirectory test\".",
              "Would create the content link files a.txt.md5 and b.txt.md5 and create a copy of the input files "
              "renamed to the hash values (the content files)."]
    parser = argparse.ArgumentParser(description=' '.join(info), epilog='\n'.join(epilog))
    parser.add_argument("--testresults", help="Name of a test results file to process. "
                                              "This is a json file containing the results "
                                              "of failed system tests")
    parser.add_argument("--replacecontentlinks", action="store_true",
                        help="Whether to automatically replace the original content link files with "
                             "the newly generated files")
    parser.add_argument('--inputfiles', nargs='+', help="List of input files to create test data for ")
    parser.add_argument("--targetdirectory", nargs='+', type=dir_path,
                        help="Moves the created files data files to the target directory")
    options = parser.parse_args()

    creator = TestDataCreator()
    if options.testresults and os.path.isfile(options.testresults):
        with open(options.testresults) as json_file:
            json_data = json.load(json_file)
            creator.process_test_failures(json_data, options.replacecontentlinks)

    if options.inputfiles:
        for input_option in options.inputfiles:
            files = glob.glob(input_option)
            creator.process_files(files)
        if options.targetdirectory:
            creator.move_content_link_files(options.targetdirectory)

    creator.print_summary()


if __name__ == '__main__':
    main()
